import axios from 'axios';
import { processMediaUrls } from './cdn-utils';

const strapiAPI = axios.create({
  baseURL: process.env.NEXT_PUBLIC_STRAPI_API_URL || 'https://wonderful-serenity-47deffe3a2.strapiapp.com/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Ê∑ªÂä†ËØ∑Ê±ÇÊã¶Êà™Âô®Êù•Â§ÑÁêÜËÆ§ËØÅ
strapiAPI.interceptors.request.use((config) => {
  const token = process.env.STRAPI_API_TOKEN;
  console.log('üîë API Token check:', {
    hasToken: !!token,
    tokenLength: token?.length || 0,
    tokenPreview: token ? `${token.substring(0, 10)}...` : 'null',
    isDefaultToken: token === 'your_readonly_token_here' || token === 'your_api_token_here'
  });
  
  if (token && token !== 'your_readonly_token_here' && token !== 'your_api_token_here') {
    config.headers.Authorization = `Bearer ${token}`;
    console.log('‚úÖ Authorization header added');
  } else {
    console.warn('‚ö†Ô∏è No valid API token found or using default placeholder');
  }
  return config;
});

// Ê∑ªÂä†ÂìçÂ∫îÊã¶Êà™Âô®ÔºöËá™Âä®Â§ÑÁêÜÂõæÁâáURLËΩ¨Êç¢‰∏∫CDN
strapiAPI.interceptors.response.use(
  (response) => {
    if (response.data) {
      response.data = processMediaUrls(response.data);
    }
    return response;
  },
  (error) => {
    console.error('Strapi API Error:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.response?.data?.error?.message || error.message,
    });
    return Promise.reject(error);
  }
);

// ÂìçÂ∫îÊï∞ÊçÆÁ±ªÂûãÂÆö‰πâ - Êõ¥Êñ∞‰∏∫Strapi 5Ê†ºÂºè
export interface StrapiResponse<T> {
  data: (T & {
    id: number;
    documentId: string;
    locale?: string;
    createdAt: string;
    updatedAt: string;
    publishedAt?: string;
  })[];
  meta: {
    pagination: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

export interface StrapiSingleResponse<T> {
  data: T & {
    id: number;
    documentId: string;
    locale?: string;
    createdAt: string;
    updatedAt: string;
    publishedAt?: string;
  };
  meta: {};
}

export interface Page {
  title: string;
  slug: string;
  content: string;
  seo_title?: string;
  seo_description?: string;
  featured_image?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
}

export interface Article {
  documentId?: string;
  title: string;
  slug: string;
  description?: string;
  descript?: string;
  content?: string;
  cover?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    formats?: {
      small?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      thumbnail?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
    };
    hash?: string;
    ext?: string;
    mime?: string;
    size?: number;
    url: string;
    previewUrl?: string;
    provider?: string;
    provider_metadata?: any;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  } | null;
  author?: {
    id?: number;
    documentId?: string;
    name: string;
    email: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  } | null;
  category?: {
    id?: number;
    documentId?: string;
    name: string;
    slug: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  } | null;
  blocks?: any[] | null;
  locale?: string;
  createdAt: string;
  updatedAt: string;
  publishedAt: string;
}

export interface Sector {
  id?: number;
  documentId?: string;
  title: string;
  date: string;
  content: string;
  source?: string;
  descript?: string;
  artcileId?: string;
  type: 'Network' | 'Datacenter' | 'Data' | 'Cloud' | 'AI' | 'Security';
  cover?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    formats?: {
      small?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      thumbnail?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
    };
    hash?: string;
    ext?: string;
    mime?: string;
    size?: number;
    url: string;
    previewUrl?: string;
    provider?: string;
    provider_metadata?: any;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
  attach?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  }[];
  locale?: string;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
}

export interface Event {
  id?: number;
  documentId?: string;
  title: string;
  date: string;
  content: string;
  location?: string;
  type?: string;
  cover?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    formats?: {
      small?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      thumbnail?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
    };
    hash?: string;
    ext?: string;
    mime?: string;
    size?: number;
    url: string;
    previewUrl?: string;
    provider?: string;
    provider_metadata?: any;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
  locale?: string;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
}

export interface Resource {
  id?: number;
  documentId?: string;
  title: string;
  content: string;
  type?: string;
  cover?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    formats?: {
      small?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      thumbnail?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
    };
    hash?: string;
    ext?: string;
    mime?: string;
    size?: number;
    url: string;
    previewUrl?: string;
    provider?: string;
    provider_metadata?: any;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
  attachments?: {
    id?: number;
    documentId?: string;
    name: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    ext: string;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  }[];
  locale?: string;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
}

// ÂÆö‰πâÈÄöÁî®ÁöÑÊñá‰ª∂Êé•Âè£
interface StrapiFile {
  id?: number;
  documentId?: string;
  name?: string;
  alternativeText?: string;
  caption?: string;
  width?: number;
  height?: number;
  formats?: any;
  hash?: string;
  ext?: string;
  mime?: string;
  size?: number;
  url: string;
  previewUrl?: string;
  provider?: string;
  provider_metadata?: any;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
}

export interface About {
  title: string;
  blocks?: any[];
  video?: StrapiFile[];
  aboutDwnUrl?: StrapiFile;
  MembershipDownloadUrl?: StrapiFile;
  ConstitutionDownloadUrl?: StrapiFile;
}

export interface Joinus {
  title: string;
  blocks?: any[];
  download?: StrapiFile;
}

export interface BannerSwiper {
  id?: number;
  title: string;
  description: string;
  remark?: string;
  images?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    formats?: {
      large?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      medium?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      small?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
      thumbnail?: {
        ext: string;
        url: string;
        hash: string;
        mime: string;
        name: string;
        path?: string;
        size: number;
        width: number;
        height: number;
        sizeInBytes: number;
      };
    };
    hash?: string;
    ext?: string;
    mime?: string;
    size?: number;
    url: string;
    previewUrl?: string;
    provider?: string;
    provider_metadata?: any;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
}

export interface Home {
  title: string;
  blocks?: any[];
  bannerSwiper?: BannerSwiper[];
}

export interface Global {
  siteName: string;
  siteDescription: string;
  logo?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
  favicon?: {
    id?: number;
    documentId?: string;
    name?: string;
    alternativeText?: string;
    caption?: string;
    width?: number;
    height?: number;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    publishedAt?: string;
  };
}

// Ëé∑ÂèñÈ°µÈù¢ÂÜÖÂÆπ
export const getPageContent = async (slug: string): Promise<Page | null> => {
  try {
    const response = await strapiAPI.get<StrapiResponse<Page>>(
      `/pages?filters[slug][$eq]=${slug}`
    );
    
    if (response.data.data.length === 0) {
      return null;
    }
    
    return response.data.data[0];
  } catch (error) {
    console.error('Error fetching page content:', error);
    return null;
  }
};

// Ëé∑ÂèñÊâÄÊúâÈ°µÈù¢ÔºàÁî®‰∫éÈùôÊÄÅË∑ØÂæÑÁîüÊàêÔºâ
export const getAllPages = async (): Promise<{ slug: string }[]> => {
  try {
    // ÂÖàÂ∞ùËØï‰ªé articles Ëé∑ÂèñÈ°µÈù¢Êï∞ÊçÆÔºåÂõ†‰∏∫ pages Á´ØÁÇπÂèØËÉΩ‰∏çÂ≠òÂú®
    const response = await strapiAPI.get<StrapiResponse<{ slug: string }>>(
      '/articles?fields[0]=slug'
    );
    
    // ÂÆâÂÖ®Âú∞Â§ÑÁêÜÂìçÂ∫îÊï∞ÊçÆ
    if (!response.data.data || !Array.isArray(response.data.data)) {
      console.warn('Invalid articles data structure for pages:', response.data);
      return [];
    }
    
    // ËøáÊª§Êéâ‰∏éÈùôÊÄÅÈ°µÈù¢ÂÜ≤Á™ÅÁöÑË∑ØÂæÑ
    const staticRoutes = ['about', 'join-us', 'activities-services', 'training', 'events', 'standards', 'news', 'certifications'];
    
    return response.data.data
      .map((page) => {
        // Á°Æ‰øù slug Â≠òÂú®
        if (!page.slug) {
          return null;
        }
        return { slug: page.slug };
      })
      .filter((page): page is { slug: string } => 
        page !== null && 
        !staticRoutes.includes(page.slug) // ÊéíÈô§‰∏éÈùôÊÄÅË∑ØÁî±ÂÜ≤Á™ÅÁöÑË∑ØÂæÑ
      );
  } catch (error) {
    console.error('Error fetching all pages:', error);
    // Â¶ÇÊûú API Â§±Ë¥•ÔºåËøîÂõûÁ©∫Êï∞ÁªÑËÄå‰∏çÊòØÂõ∫ÂÆöË∑ØÁî±ÔºàÈÅøÂÖçÂÜ≤Á™ÅÔºâ
    return [];
  }
};

// Ëé∑ÂèñÊñáÁ´†ÂàóË°® - Êõ¥Êñ∞‰∏∫Strapi 5Ê†ºÂºè
export const getArticles = async (limit?: number, locale: string = 'en'): Promise<Article[]> => {
  try {
    const queryParams = new URLSearchParams({
      'sort': 'publishedAt:desc'
    });
    
    if (limit) {
      queryParams.append('pagination[limit]', limit.toString());
    }
    
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
    }
    
    const response = await strapiAPI.get<StrapiResponse<Article>>(
      `/articles?${queryParams.toString()}`
    );
    
    // Ê£ÄÊü•ÂìçÂ∫îÊï∞ÊçÆÁªìÊûÑ
    if (!response.data || !response.data.data || !Array.isArray(response.data.data)) {
      console.warn('Invalid articles data structure:', response.data);
      return [];
    }
    
    return response.data.data
      .map((article) => {
        // Strapi 5 ËøîÂõûÂπ≥Èù¢ÁªìÊûÑ
        console.log('Processing article:', article);
        
        // Á°Æ‰øùÂøÖÈúÄÂ≠óÊÆµÂ≠òÂú®
        if (!article.title || !article.slug) {
          console.warn('Article missing required fields:', article);
          return null;
        }
        
        return {
          documentId: article.documentId,
          title: article.title,
          slug: article.slug,
          description: article.description,
          descript: article.descript,
          cover: article.cover || null,
          author: article.author || null,
          category: article.category || null,
          blocks: article.blocks || null,
          locale: article.locale || 'en',
          createdAt: article.createdAt,
          updatedAt: article.updatedAt,
          publishedAt: article.publishedAt || article.createdAt,
        } as Article;
      })
      .filter((article): article is Article => article !== null);
  } catch (error) {
    console.error('Error fetching articles:', error);
    return [];
  }
};

// Ê†πÊçÆdocumentIdËé∑ÂèñÊñáÁ´† - Strapi 5ÁâàÊú¨
export const getArticleByDocumentId = async (documentId: string, locale: string = 'en'): Promise<Article | null> => {
  try {
    const queryParams = new URLSearchParams();
    
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
    }
    
    const url = `/articles/${documentId}${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
    const response = await strapiAPI.get<StrapiSingleResponse<Article>>(url);
    
    if (!response.data.data) {
      return null;
    }
    
    const article = response.data.data;
    
    // Á°Æ‰øùÂøÖÈúÄÂ≠óÊÆµÂ≠òÂú®
    if (!article.title) {
      console.warn('Article missing required fields:', article);
      return null;
    }
    
    return {
      documentId: article.documentId,
      title: article.title,
      slug: article.slug || '',
      description: article.description,
      descript: article.descript,
      cover: article.cover || null,
      author: article.author || null,
      category: article.category || null,
      blocks: article.blocks || null,
      locale: article.locale,
      createdAt: article.createdAt,
      updatedAt: article.updatedAt,
      publishedAt: article.publishedAt || article.createdAt,
    } as Article;
  } catch (error) {
    console.error('Error fetching article by documentId:', error);
    return null;
  }
};

// Ê†πÊçÆslugËé∑ÂèñÊñáÁ´†Ôºà‰øùÁïôÂÖºÂÆπÊÄßÔºâ
export const getArticleBySlug = async (slug: string): Promise<Article | null> => {
  try {
    const response = await strapiAPI.get<StrapiResponse<Article>>(
      `/articles?filters[slug][$eq]=${slug}`
    );
    
    if (!response.data.data || response.data.data.length === 0) {
      return null;
    }
    
    const article = response.data.data[0];
    
    // Á°Æ‰øùÂøÖÈúÄÂ≠óÊÆµÂ≠òÂú®
    if (!article.title || !article.slug) {
      console.warn('Article missing required fields:', article);
      return null;
    }
    
    return {
      documentId: article.documentId,
      title: article.title,
      slug: article.slug,
      description: article.description,
      descript: article.descript,
      cover: article.cover || null,
      author: article.author || null,
      category: article.category || null,
      blocks: article.blocks || null,
      locale: article.locale,
      createdAt: article.createdAt,
      updatedAt: article.updatedAt,
      publishedAt: article.publishedAt || article.createdAt,
    } as Article;
  } catch (error) {
    console.error('Error fetching article:', error);
    return null;
  }
};

// Ëé∑ÂèñÊâÄÊúâÊñáÁ´†slugÔºàÁî®‰∫éÈùôÊÄÅË∑ØÂæÑÁîüÊàêÔºâ
export const getAllArticles = async (): Promise<{ slug: string }[]> => {
  try {
    const response = await strapiAPI.get<StrapiResponse<{ slug: string }>>(
      '/articles?fields[0]=slug'
    );
    
    return response.data.data.map((article) => ({
      slug: article.slug,
    }));
  } catch (error) {
    console.error('Error fetching all articles:', error);
    return [];
  }
};

// Ëé∑ÂèñÊùøÂùó‰ø°ÊÅØ
export const getTraining = async (type?: string, locale: string = 'en'): Promise<Sector[]> => {
  try {
    // ÊûÑÂª∫Êü•ËØ¢ÂèÇÊï∞
    const queryParams = new URLSearchParams({
      'sort': 'createdAt:desc',
      'populate': '*'
    });
    
    // Â¶ÇÊûúÊåáÂÆö‰∫ÜËØ≠Ë®Ä‰∏î‰∏çÊòØÈªòËÆ§ËØ≠Ë®ÄÔºåÊ∑ªÂä†localeÂèÇÊï∞
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
      console.log(`üîÑ ‰ΩøÁî® locale: ${locale}`);
    }

    console.log(`Fetching training with locale: ${locale}, type: ${type || 'all'}`);
    
    const response = await strapiAPI.get<StrapiResponse<Sector>>(
      `/trainings?${queryParams.toString()}`
    );
    
    console.log('Training API response status:', response.status);
    console.log('Training data length:', response.data.data?.length || 0);
    
    if (!response.data.data || !Array.isArray(response.data.data)) {
      console.warn('Invalid training response format');
      return [];
    }
    
    let training = response.data.data.map((sector: any) => {
      // Ë∞ÉËØïÊó•ÂøóÔºöÊâìÂç∞ÂéüÂßãÊï∞ÊçÆÁªìÊûÑ
      console.log('Raw training data:', {
        id: sector.id,
        documentId: sector.documentId,
        artcileId: sector.artcileId || sector.attributes?.artcileId,
        hasAttributes: !!sector.attributes,
        coverFromRoot: sector.cover,
        coverFromAttributes: sector.attributes?.cover,
        finalCover: sector.cover || sector.attributes?.cover
      });
      
      // ‰ºòÂåñÊï∞ÊçÆÁªìÊûÑÂ§ÑÁêÜ
      if (sector.attributes) {
        return { 
          ...sector.attributes, 
          id: sector.id,
          documentId: sector.documentId,
          locale: sector.locale || 'en',
          // Á°Æ‰øùÊâÄÊúâÂèØËÉΩ‰∏∫undefinedÁöÑÂ≠óÊÆµÈÉΩËÆæ‰∏∫null
          attach: sector.attributes.attach || null,
          cover: sector.attributes.cover || null,
          author: sector.attributes.author || null,
          createdAt: sector.attributes.createdAt || null,
          updatedAt: sector.attributes.updatedAt || null,
          publishedAt: sector.attributes.publishedAt || null
        };
      } else {
        // ÂØπ‰∫éÊ≤°ÊúâattributesÁöÑÊÉÖÂÜµÔºåÁõ¥Êé•‰ΩøÁî®sectorÂØπË±°
        return {
          id: sector.id,
          documentId: sector.documentId,
          title: sector.title || '',
          date: sector.date || null,
          content: sector.content || '',
          source: sector.source || null,
          descript: sector.descript || '',
          artcileId: sector.artcileId || null,
          type: sector.type || 'Network',
          locale: sector.locale || 'en',
          // Áõ¥Êé•‰ΩøÁî®sectorÂØπË±°‰∏≠ÁöÑÂ≠óÊÆµ
          attach: sector.attach || null,
          cover: sector.cover || null,
          author: sector.author || null,
          createdAt: sector.createdAt || null,
          updatedAt: sector.updatedAt || null,
          publishedAt: sector.publishedAt || null
        };
      }
    });
    
    // Âú®ÂâçÁ´ØËøõË°åÁ≠õÈÄâ
    if (type) {
      training = training.filter((sector: Sector) => sector.type === type);
      console.log(`Filtered training by type '${type}':`, training.length);
    }
    
    return training;
  } catch (error: any) {
    console.error('Error fetching training:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data,
      url: error.config?.url
    });
    
    // Â¶ÇÊûúÊòØ403ÈîôËØØ‰∏î‰ΩøÁî®‰∫ÜlocaleÂèÇÊï∞ÔºåÂ∞ùËØï‰∏ç‰ΩøÁî®localeÈáçÊñ∞ËØ∑Ê±Ç
    if (error.response?.status === 403 && locale !== 'en') {
      console.warn('üîí 403 error with locale, trying fallback to English...');
      try {
        return await getTraining(type, 'en');
      } catch (fallbackError) {
        console.error('Fallback request also failed:', fallbackError);
      }
    }
    
    // Â¶ÇÊûúÊòØËÆ§ËØÅÈîôËØØÊàñÁΩëÁªúÈîôËØØÔºåËøîÂõûÁ©∫Êï∞ÁªÑËÄå‰∏çÊòØÊäõÂá∫ÈîôËØØ
    if (error.response?.status === 401 || error.response?.status === 403 || error.code === 'ENOTFOUND') {
      console.warn('üîí Authentication or network error. Returning empty array.');
      return [];
    }
    
    return [];
  }
};

// Ëé∑Âèñ‰∫ã‰ª∂ÂàóË°®
export const getEvents = async (limit?: number, locale: string = 'en'): Promise<Event[]> => {
  try {
    console.log(`üîÑ Ê≠£Âú®Ëé∑ÂèñEventsÊï∞ÊçÆ (${locale})...`);
    
    const queryParams = new URLSearchParams();
    
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
      console.log(`üîÑ ‰ΩøÁî® locale: ${locale}`);
    } else {
      console.log(`üîÑ ‰ΩøÁî®ÈªòËÆ§ locale: en`);
    }
    
    // Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆö limitÔºåËÆæÁΩÆ‰∏Ä‰∏™ËæÉÂ§ßÁöÑÂÄºÁ°Æ‰øùËé∑ÂèñÊâÄÊúâÊï∞ÊçÆ
    if (limit) {
      queryParams.append('pagination[limit]', limit.toString());
    } else {
      // ËÆæÁΩÆ‰∏Ä‰∏™Ë∂≥Â§üÂ§ßÁöÑ limit Á°Æ‰øùËé∑ÂèñÊâÄÊúâÊï∞ÊçÆ
      queryParams.append('pagination[limit]', '100');
    }
    
    queryParams.append('sort', 'date:desc');
    queryParams.append('populate', '*');
    
    const url = `/events${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
    
    console.log(`üåê ÂÆåÊï¥ÁöÑ Events API URL: ${url}`);
    console.log(`üîç Êü•ËØ¢ÂèÇÊï∞ËØ¶ÊÉÖ:`, Object.fromEntries(queryParams.entries()));
    
    const response = await strapiAPI.get<StrapiResponse<Event>>(url);
    
    // ÊâìÂç∞ÂàÜÈ°µ‰ø°ÊÅØÁî®‰∫éË∞ÉËØï
    console.log(`üìä Events API ÂàÜÈ°µ‰ø°ÊÅØ:`, {
      page: response.data.meta?.pagination?.page,
      pageSize: response.data.meta?.pagination?.pageSize,
      pageCount: response.data.meta?.pagination?.pageCount,
      total: response.data.meta?.pagination?.total,
      dataLength: response.data.data?.length
    });
    
    const events = response.data.data.map((event: any) => {
      // Ë∞ÉËØïÊó•ÂøóÔºöÊâìÂç∞EventsÊï∞ÊçÆÁªìÊûÑ
      console.log('Raw event data:', {
        id: event.id,
        title: event.title,
        locale: event.locale,
        hasAttributes: !!event.attributes,
        cover: event.cover || event.attributes?.cover
      });
      
      // Â§ÑÁêÜÊï∞ÊçÆÁªìÊûÑ
      if (event.attributes) {
        return {
          id: event.id,
          documentId: event.documentId,
          title: event.attributes.title,
          date: event.attributes.date,
          content: event.attributes.content,
          location: event.attributes.location,
          type: event.attributes.type,
          cover: event.attributes.cover,
          locale: event.locale,
          createdAt: event.attributes.createdAt,
          updatedAt: event.attributes.updatedAt,
          publishedAt: event.attributes.publishedAt,
        };
      } else {
        return {
          id: event.id,
          documentId: event.documentId,
          title: event.title,
          date: event.date,
          content: event.content,
          location: event.location,
          type: event.type,
          cover: event.cover,
          locale: event.locale,
          createdAt: event.createdAt,
          updatedAt: event.updatedAt,
          publishedAt: event.publishedAt,
        };
      }
    });
    
    console.log(`‚úÖ ÊàêÂäüËé∑Âèñ ${events.length} Êù°EventsÊï∞ÊçÆ`);
    return events;
  } catch (error: any) {
    console.error('‚ùå Ëé∑ÂèñEventsÊï∞ÊçÆÂ§±Ë¥•:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data,
      url: error.config?.url
    });
    
    // Â¶ÇÊûúÊòØ403ÈîôËØØ‰∏î‰ΩøÁî®‰∫ÜlocaleÂèÇÊï∞ÔºåÂ∞ùËØï‰∏ç‰ΩøÁî®localeÈáçÊñ∞ËØ∑Ê±Ç
    if (error.response?.status === 403 && locale !== 'en') {
      console.warn('üîí 403 error with locale, trying fallback to English...');
      try {
        return await getEvents(limit, 'en');
      } catch (fallbackError) {
        console.error('Fallback request also failed:', fallbackError);
      }
    }
    
    return [];
  }
};

// Ëé∑ÂèñÊ†áÂáÜÂàóË°®
export const getStandards = async (type?: string): Promise<Resource[]> => {
  try {
    const queryParams = new URLSearchParams();
    
    if (type) {
      queryParams.append('filters[type][$eq]', type);
    }
    
    queryParams.append('populate', '*');
    queryParams.append('sort', 'createdAt:desc');
    
    const response = await strapiAPI.get<StrapiResponse<Resource>>(
      `/standards?${queryParams.toString()}`
    );
    
    return response.data.data.map((resource: any) => {
      // Ë∞ÉËØïÊó•ÂøóÔºöÊâìÂç∞StandardsÊï∞ÊçÆÁªìÊûÑ
      console.log('Raw standards data:', {
        id: resource.id,
        title: resource.title || resource.attributes?.title,
        hasAttributes: !!resource.attributes,
        cover: resource.cover || resource.attributes?.cover
      });
      
      // Â§ÑÁêÜÊï∞ÊçÆÁªìÊûÑ
      if (resource.attributes) {
        return {
          id: resource.id,
          documentId: resource.documentId,
          title: resource.attributes.title,
          content: resource.attributes.content,
          type: resource.attributes.type,
          cover: resource.attributes.cover,
          attachments: resource.attributes.attachments,
          locale: resource.locale || 'en',
          createdAt: resource.attributes.createdAt,
          updatedAt: resource.attributes.updatedAt,
          publishedAt: resource.attributes.publishedAt,
        };
      } else {
        return {
          id: resource.id,
          documentId: resource.documentId,
          title: resource.title,
          content: resource.content,
          type: resource.type,
          cover: resource.cover,
          attachments: resource.attachments,
          locale: resource.locale || 'en',
          createdAt: resource.createdAt,
          updatedAt: resource.updatedAt,
          publishedAt: resource.publishedAt,
        };
      }
    });
  } catch (error) {
    console.error('Error fetching standards:', error);
    return [];
  }
};

// Ëé∑ÂèñÂÖ≥‰∫éÊàë‰ª¨‰ø°ÊÅØ
export const getAbout = async (): Promise<About | null> => {
  try {
    console.log('üìÑ Starting getAbout API call...');
    console.log('üåê API URL:', strapiAPI.defaults.baseURL + '/about?populate=*');
    
    const response = await strapiAPI.get<StrapiSingleResponse<About>>(
      '/about?populate=*'
    );
    
    console.log('‚úÖ About API response status:', response.status);
    const aboutData = response.data.data;
    
    if (aboutData) {
      console.log('üìÑ About data found:');
      console.log('  - Title:', aboutData.title);
      console.log('  - Has video:', !!aboutData.video);
      console.log('  - Has aboutDwnUrl:', !!aboutData.aboutDwnUrl);
      console.log('  - Has MembershipDownloadUrl:', !!aboutData.MembershipDownloadUrl);
      console.log('  - Has ConstitutionDownloadUrl:', !!aboutData.ConstitutionDownloadUrl);
      
      // ÊâìÂç∞‰∏ãËΩΩÈìæÊé•‰ø°ÊÅØ
      if (aboutData.aboutDwnUrl) {
        console.log(`  - aboutDwnUrl: ${aboutData.aboutDwnUrl.url} (${aboutData.aboutDwnUrl.ext})`);
      }
      if (aboutData.MembershipDownloadUrl) {
        console.log(`  - MembershipDownloadUrl: ${aboutData.MembershipDownloadUrl.url} (${aboutData.MembershipDownloadUrl.ext})`);
      }
      if (aboutData.ConstitutionDownloadUrl) {
        console.log(`  - ConstitutionDownloadUrl: ${aboutData.ConstitutionDownloadUrl.url} (${aboutData.ConstitutionDownloadUrl.ext})`);
      }
    } else {
      console.log('‚ùå No about data in response');
    }
    
    return aboutData;
  } catch (error: any) {
    console.error('‚ùå Error fetching about:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data
    });
    return null;
  }
};

// Ëé∑ÂèñJoinus‰ø°ÊÅØ
export const getJoinus = async (): Promise<Joinus | null> => {
  try {
    console.log('ü§ù Starting getJoinus API call...');
    console.log('üåê API URL:', strapiAPI.defaults.baseURL + '/joinus?populate=*');
    
    const response = await strapiAPI.get<StrapiSingleResponse<Joinus>>(
      '/joinus?populate=*'
    );
    
    console.log('‚úÖ Joinus API response status:', response.status);
    const joinusData = response.data.data;
    
    if (joinusData) {
      console.log('ü§ù Joinus data found:');
      console.log('  - Title:', joinusData.title);
      console.log('  - Has download:', !!joinusData.download);
      
      // ÊâìÂç∞‰∏ãËΩΩÊñá‰ª∂‰ø°ÊÅØ
      if (joinusData.download) {
        console.log(`  - Download file: ${joinusData.download.name}`);
        console.log(`  - Download URL: ${joinusData.download.url}`);
        console.log(`  - File type: ${joinusData.download.ext} (${joinusData.download.mime})`);
        console.log(`  - File size: ${joinusData.download.size} KB`);
      }
    } else {
      console.log('‚ùå No joinus data in response');
    }
    
    return joinusData;
  } catch (error: any) {
    console.error('‚ùå Error fetching joinus:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data
    });
    return null;
  }
};

// Ëé∑ÂèñHome‰ø°ÊÅØ
export const getHome = async (): Promise<Home | null> => {
  try {
    console.log('üè† Starting getHome API call...');
    console.log('üåê API URL:', strapiAPI.defaults.baseURL + '/home?populate[bannerSwiper][populate]=*');
    
    const response = await strapiAPI.get<StrapiSingleResponse<Home>>(
      '/home?populate[bannerSwiper][populate]=*'
    );
    
    console.log('‚úÖ Home API response status:', response.status);
    console.log('üìä Home API response data:', JSON.stringify(response.data, null, 2));
    
    const homeData = response.data.data;
    if (homeData) {
      console.log('üè† Home data found:');
      console.log('  - Title:', homeData.title);
      console.log('  - Has bannerSwiper:', !!homeData.bannerSwiper);
      console.log('  - BannerSwiper type:', typeof homeData.bannerSwiper);
      console.log('  - BannerSwiper is array:', Array.isArray(homeData.bannerSwiper));
      
      if (homeData.bannerSwiper) {
        console.log('  - BannerSwiper count:', homeData.bannerSwiper.length);
        if (Array.isArray(homeData.bannerSwiper)) {
          homeData.bannerSwiper.forEach((item, index) => {
            console.log(`  - Banner ${index + 1}:`);
            console.log(`    - Title: ${item.title}`);
            console.log(`    - Description: ${item.description}`);
            console.log(`    - Remark: ${item.remark}`);
            console.log(`    - Has images: ${!!item.images}`);
            if (item.images) {
              console.log(`      - Image URL: ${item.images.url}`);
              console.log(`      - Image formats available: ${Object.keys(item.images.formats || {}).join(', ')}`);
            }
          });
        }
      }
    } else {
      console.log('‚ùå No home data in response');
    }
    
    return homeData;
  } catch (error: any) {
    console.error('‚ùå Error fetching home:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data
    });
    return null;
  }
};

// Ëé∑ÂèñÂÖ®Â±ÄËÆæÁΩÆ
export const getGlobal = async (): Promise<Global | null> => {
  try {
    const response = await strapiAPI.get<StrapiSingleResponse<Global>>(
      '/global'
    );
    
    return response.data.data;
  } catch (error) {
    console.error('Error fetching global settings:', error);
    return null;
  }
};

// Ëé∑ÂèñËÆ§ËØÅËµÑËÆØ
export const getCertifications = async (limit?: number, locale: string = 'en'): Promise<Article[]> => {
  try {
    console.log(`üîÑ Ê≠£Âú®Ëé∑ÂèñCertificationsÊï∞ÊçÆ (${locale})...`);
    
    const queryParams = new URLSearchParams();
    
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
      console.log(`üîÑ ‰ΩøÁî® locale: ${locale}`);
    }
    
    if (limit) {
      queryParams.append('pagination[limit]', limit.toString());
    }
    
    queryParams.append('sort', 'publishedAt:desc');
    queryParams.append('populate', '*');
    
    const url = `/certifications${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
    
    console.log(`üåê ÂÆåÊï¥ÁöÑ Certifications API URL: ${url}`);
    console.log(`üîç Êü•ËØ¢ÂèÇÊï∞ËØ¶ÊÉÖ:`, Object.fromEntries(queryParams.entries()));
    
    const response = await strapiAPI.get<StrapiResponse<Article>>(url);
    
    const articles = response.data.data.map((news: any) => {
      // Ë∞ÉËØïÊó•ÂøóÔºöÊâìÂç∞CertificationsÊï∞ÊçÆÁªìÊûÑ
      console.log('Raw certifications data:', {
        id: news.id,
        title: news.title || news.attributes?.title,
        locale: news.locale,
        hasAttributes: !!news.attributes,
        cover: news.cover || news.attributes?.cover
      });
      
      // Â§ÑÁêÜÊï∞ÊçÆÁªìÊûÑ
      if (news.attributes) {
        return {
          documentId: news.documentId,
          title: news.attributes.title,
          slug: news.attributes.slug,
          description: news.attributes.description,
          descript: news.attributes.descript,
          content: news.attributes.content,
          cover: news.attributes.cover,
          author: news.attributes.author,
          category: news.attributes.category,
          blocks: news.attributes.blocks,
          locale: news.locale,
          createdAt: news.attributes.createdAt,
          updatedAt: news.attributes.updatedAt,
          publishedAt: news.attributes.publishedAt,
        };
      } else {
        return {
          documentId: news.documentId,
          title: news.title,
          slug: news.slug,
          description: news.description,
          descript: news.descript,
          content: news.content,
          cover: news.cover,
          author: news.author,
          category: news.category,
          blocks: news.blocks,
          locale: news.locale,
          createdAt: news.createdAt,
          updatedAt: news.updatedAt,
          publishedAt: news.publishedAt,
        };
      }
    });
    
    console.log(`‚úÖ ÊàêÂäüËé∑Âèñ ${articles.length} Êù°CertificationsÊï∞ÊçÆ`);
    return articles;
  } catch (error: any) {
    console.error('‚ùå Ëé∑ÂèñCertificationsÊï∞ÊçÆÂ§±Ë¥•:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data,
      url: error.config?.url
    });
    
    // Â¶ÇÊûúÊòØ403ÈîôËØØ‰∏î‰ΩøÁî®‰∫ÜlocaleÂèÇÊï∞ÔºåÂ∞ùËØï‰∏ç‰ΩøÁî®localeÈáçÊñ∞ËØ∑Ê±Ç
    if (error.response?.status === 403 && locale !== 'en') {
      console.warn('üîí 403 error with locale, trying fallback to English...');
      try {
        return await getCertifications(limit, 'en');
      } catch (fallbackError) {
        console.error('Fallback request also failed:', fallbackError);
      }
    }
    
    return [];
  }
};

// Ëé∑ÂèñÂçï‰∏™sector by artcileId
export const getTrainingById = async (artcileId: string): Promise<Sector | null> => {
  try {
    // ÂÖàÂ∞ùËØïËé∑ÂèñÊâÄÊúâtrainingÔºåÁÑ∂ÂêéÂú®ÂÆ¢Êà∑Á´ØÁ≠õÈÄâ
    const allTraining = await getTraining();
    const training = allTraining.find(s => s.artcileId === artcileId);
    
    console.log('Finding training by artcileId:', artcileId, 'Found:', !!training);
    
    return training || null;
  } catch (error: any) {
    console.error('Error fetching training by ID:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data
    });
    
    return null;
  }
};

// Ê†πÊçÆdocumentIdËé∑ÂèñSector - Strapi 5ÁâàÊú¨
export const getSectorByDocumentId = async (documentId: string, locale: string = 'en'): Promise<Sector | null> => {
  try {
    const queryParams = new URLSearchParams();
    
    if (locale && locale !== 'en') {
      queryParams.append('locale', locale);
    }
    
    const url = `/sectors/${documentId}${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
    const response = await strapiAPI.get<StrapiSingleResponse<Sector>>(url);
    
    if (!response.data.data) {
      return null;
    }
    
    const sector = response.data.data;
    
    return {
      id: sector.id,
      documentId: sector.documentId,
      title: sector.title,
      date: sector.date,
      content: sector.content,
      source: sector.source,
      descript: sector.descript,
      artcileId: sector.artcileId,
      type: sector.type,
      attach: sector.attach,
      locale: sector.locale,
      createdAt: sector.createdAt,
      updatedAt: sector.updatedAt,
      publishedAt: sector.publishedAt,
    } as Sector;
  } catch (error) {
    console.error('Error fetching sector by documentId:', error);
    return null;
  }
};

// Ê†πÊçÆarticleIdÂíåËØ≠Ë®ÄËé∑ÂèñÂØπÂ∫îÁöÑtraining
export const getTrainingByArticleIdAndLanguage = async (artcileId: string, language: string): Promise<Sector | null> => {
  try {
    const training = await getTraining(undefined, language);
    return training.find(training => training.artcileId === artcileId) || null;
  } catch (error) {
    console.error('Error fetching training by articleId and language:', error);
    return null;
  }
};

export default strapiAPI; 